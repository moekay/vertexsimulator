function [] = runSimulation(params, connections, electrodes)
%RUNSIMULATION Run the simulation given the model generated by INITNETWORK.
%   RUNSIMULATION(PARAMS, CONNECTIONS, ELECTRODES) runs the simulation
%   given the model generated by INITNETWORK. PARAMS, CONNECTIONS and
%   ELECTRODES are the PARAMS, CONNECTIONS and ELECTRODES outputs from the
%   INITNETWORK function. RUNSIMULATION automatically saves the simulation
%   results in the directory specified by the user in the recording
%   settings structure given to INITNETWORK.

TP = params.TissueParams;
NP = params.NeuronParams;
CP = params.ConnectionParams;
RS = params.RecordingSettings;
SS = params.SimulationSettings;

outputDirectory = RS.saveDir;
if ~strcmpi(outputDirectory(end), '/')
  outputDirectory = [outputDirectory '/'];
end

if exist(outputDirectory, 'dir') ~= 7
  mkdir(outputDirectory);
end
RS.saveDir = outputDirectory;

if isfield(SS,'spikeLoad') 
  if SS.spikeLoad
    if ~isfield(SS, 'spikeLoadDir')
      inputDirectory = outputDirectory;
      SS.spikeLoadDir = inputDirectory;
    end
  end
end

% Calculate passive neuron properties in correct units
NP = calculatePassiveProperties(NP, TP);

loadedSpikeTimeCell = cell(TP.numGroups, 1);
for iGroup = 1:TP.numGroups
  if strcmpi(NP(iGroup).neuronModel, 'loadspiketimes')
    spkfile = NP(iGroup).spikeTimeFile; % check spikeTimeDir is a field
    if exist(spkfile,'file') ~= 2
      errMsg = ['The specified spike time file for neuron group ' ...
                 num2str(iGroup) ' does not exist.'];
      error('vertex:runSimulation:spikeTimeDirError', errMsg);
    else
      loadedSpikeTimes = load(spkfile);
      fName = fields(loadedSpikeTimes);
      loadedSpikeTimeCell{iGroup} = loadedSpikeTimes.(fName{1});
      for ii = 1:length(loadedSpikeTimeCell{iGroup})
        loadedSpikeTimeCell{iGroup}{ii} = ...
          sort(round(loadedSpikeTimeCell{iGroup}{ii} ./ SS.timeStep));
      end
    end
  end
end

[NeuronIDMap] = setupNeuronIDMapping(TP, SS);

% Use model types as function handles. Initialisation: returns a struct
% with relevant variable cellarrays initialised as fields. Simulation:
% takes struct and uses known field names for simulation.

[NeuronModelArr] = ...
  setupNeuronDynamicVars(TP, NP, SS, NeuronIDMap, loadedSpikeTimeCell);

[SynapseModelArr, synMapCell] = setupSynapseDynamicVars(TP, NP, CP, SS);

if isfield(NP, 'Input')
  [InputModelArr] = setupInputDynamicVars(TP, NP, SS);
else
  InputModelArr = [];
end

[RS, RecordingVars] = ...
  setupRecordingVars(TP, NP, SS, RS, NeuronIDMap, electrodes);

[synapsesArrSim, weightArr] = prepareSynapsesAndWeights(TP,CP,SS,connections);

if SS.parallelSim
  simulateParallel(TP, NP, SS, RS, NeuronIDMap, NeuronModelArr, ...
    SynapseModelArr, InputModelArr, RecordingVars, synapsesArrSim, weightArr, synMapCell);
else
  simulate(TP, NP, SS, RS, NeuronIDMap, NeuronModelArr, ...
    SynapseModelArr, InputModelArr, RecordingVars, synapsesArrSim, weightArr, synMapCell);
end
  
parameterCell = {TP, NP, CP, RS, SS};

fname = [outputDirectory 'parameters.mat'];
save(fname, 'parameterCell');